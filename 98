solution 1 only work when no duplicates value exist (also can be compressed to O(n), O(1) no array)â€¨2. if condition change to left <= node < right, then should use solution 2(min/max)

def inorderHelper(allVal, node):
    if node == None:
        return
    inorderHelper(allVal, node.left)
    allVal.append(node.val)
    inorderHelper(allVal, node.right)
class Solution(object):
    def isValidBST(self, root):
        allVal = []
        inorderHelper(allVal, root)
        if len(allVal) <= 1:
            return True
        pre = None
        for i in allVal:
            if pre == None:
                pre = i
                continue
            if i <= pre:
                return False
            pre = i
        return True
def validHelper(node, min, max):
    if node == None:
        return True
    if (min != None and node.val <= min) or (max != None and node.val >= max):
        return False
    if validHelper(node.left,min,node.val) and validHelper(node.right, node.val, max):
        return True
    else:
        return False
    
class Solution(object):
    def isValidBST(self, root):
        return validHelper(root, None, None)
